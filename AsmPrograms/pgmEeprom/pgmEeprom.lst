0001   0000             #define EEPRTN_PRINTDOT
0002   0000             ;#define EEPRTN_WAITKEY
0003   0000             
0004   0000             
0005   0000             
0006   0000             #include "../includes/reuPlusDefs.asm"
0001+  0000             
0002+  0000             #ifndef DEFS
0003+  0000             
0004+  0000             #define DEFS
0005+  0000             
0006+  0000             ; REU equates
0007+  0000             REU_STAT_REG		= $DF00
0008+  0000             ; status register masks
0009+  0000             MSK_INTRPEND	= $80
0010+  0000             MSK_EOB		= $40
0011+  0000             MSK_VFYERR		= $20
0012+  0000             MSK_RAMSIZE	= $10
0013+  0000             MSK_CHIPVER	= $0F
0014+  0000             
0015+  0000             REU_CTL_REG			= $DF01
0016+  0000             ; Command register values
0017+  0000             CMD_EXECUTE	= $80
0018+  0000             CMD_AUTOLD		= $20
0019+  0000             CMD_NOFF00		= $10
0020+  0000             
0021+  0000             TTC64TOREU		= $00
0022+  0000             TTREUTOC64		= $01
0023+  0000             TTSWAP			= $02
0024+  0000             TTVFY			= $03
0025+  0000             
0026+  0000             REU_C64BASEL_REG	= $DF02
0027+  0000             REU_C64BASEH_REG	= $DF03
0028+  0000             REU_REUBASEL_REG	= $DF04
0029+  0000             REU_REUBASEM_REG	= $DF05
0030+  0000             REU_REUBASEH_REG	= $DF06
0031+  0000             REU_XFRLENL_REG		= $DF07
0032+  0000             ; all 8 bits written to this register
0033+  0000             ;	will be used. when read back
0034+  0000             ;	only bits 2..0 will be returned
0035+  0000             ;	with bits 7..3 will be '1'.
0036+  0000             ; read register REU_EXPHI8_REG to get
0037+  0000             ;	all i bits
0038+  0000             REU_XFRLENH_REG		= $DF08
0039+  0000             REU_IMSK_REG		= $DF09
0040+  0000             ; interrupt mask register masks
0041+  0000             MSK_INTRENA	= $80
0042+  0000             MSK_EOBINTR	= $40
0043+  0000             MSK_VFYINTR	= $20
0044+  0000             VAL_NOINTR		= $00
0045+  0000             
0046+  0000             REU_ADRCTL_REG		= $DF0A
0047+  0000             ; address type register values
0048+  0000             INCBOTH		= $00
0049+  0000             FIXREU		= $40
0050+  0000             FIXC64		= $80
0051+  0000             FIXBOTH		= $C0
0052+  0000             
0053+  0000             REU_REUBASESB_REG	= $DF0F
0054+  0000             
0055+  0000             REU_ROMLL_REG		= $DF10
0056+  0000             REU_ROMLH_REG		= $DF11
0057+  0000             REU_ROMHL_REG		= $DF12
0058+  0000             REU_ROMHH_REG		= $DF13
0059+  0000             REU_MEML_REG		= $DF14
0060+  0000             REU_MEMM_REG		= $DF15
0061+  0000             REU_MEMH_REG		= $DF16
0062+  0000             
0063+  0000             ; reads back all 8 bits written to
0064+  0000             ;	REU_REUBASEH_REG
0065+  0000             REU_EXPHI8_REG		= $DF0E
0066+  0000             REU_SUPERBANK_REG	= $DF0F
0067+  0000             
0068+  0000             
0069+  0000             ; Video peripheral registers
0070+  0000             VIDSTAT_REG			= $DF20
0071+  0000             VIDCHAR_REG			= $DF21
0072+  0000             
0073+  0000             ;
0074+  0000             ; selects which of the 32 banks of
0075+  0000             ;	16 mailbox registers are
0076+  0000             ;	selected for access at
0077+  0000             ;	addresses $DF30..$DF3F
0078+  0000             ;
0079+  0000             MBOXBANK_REG		= $DF26
0080+  0000             ; controls the operation of the
0081+  0000             ;	coprocessor
0082+  0000             Z80CTL_REG			= $DF27
0083+  0000             ;
0084+  0000             ; controls access to the boot ROM
0085+  0000             ;	and sets the state of EXROM
0086+  0000             ;	and GAME
0087+  0000             ;
0088+  0000             ROMSEL_REG			= $DF28
0089+  0000             
0090+  0000             
0091+  0000             I2C_CMDREG			= $DF2A
0092+  0000             I2C_CMDNOP				= $00
0093+  0000             I2C_CMDSTART			= $01
0094+  0000             I2C_CMDSTOP				= $02
0095+  0000             I2C_CMDSEND				= $03
0096+  0000             I2C_CMDRXACK			= $04
0097+  0000             I2C_CMDRXNACK			= $05
0098+  0000             ; status bits from the command register
0099+  0000             I2C_MASK_SFTRDY			= $80
0100+  0000             I2C_MASK_ACKBIT 		= $40
0101+  0000             I2C_MASK_CMDBITS 		= $07
0102+  0000             
0103+  0000             I2C_DATRDREG		= $DF2B
0104+  0000             I2C_DATWRREG		= $DF2C
0105+  0000             
0106+  0000             
0107+  0000             FPGAREV_REG			= $DF2E
0108+  0000             COP_SEL_REG			= $DF2F
0109+  0000             
0110+  0000             ; Coprocewssor mailbox registers.
0111+  0000             ;	These
0112+  0000             MBOX0_REG			= $DF30
0113+  0000             MBOX1_REG			= $DF31
0114+  0000             MBOX2_REG			= $DF32
0115+  0000             MBOX3_REG			= $DF33
0116+  0000             MBOX4_REG			= $DF34
0117+  0000             MBOX5_REG			= $DF35
0118+  0000             MBOX6_REG			= $DF36
0119+  0000             MBOX7_REG			= $DF37
0120+  0000             MBOX8_REG			= $DF38
0121+  0000             MBOX9_REG			= $DF39
0122+  0000             MBOX10_REG			= $DF3A
0123+  0000             MBOX11_REG			= $DF3B
0124+  0000             MBOX12_REG			= $DF3C
0125+  0000             MBOX13_REG			= $DF3D
0126+  0000             MBOX14_REG			= $DF3E
0127+  0000             MBOX15_REG			= $DF3F
0128+  0000             
0129+  0000             
0130+  0000             
0131+  0000             ; 6502 reset vector
0132+  0000             RST_VEC				= $FFFC
0133+  0000             
0134+  0000             
0135+  0000             
0136+  0000             ; these define veriable locations in memory
0137+  0000             ;	that is relatively safe in BASIC
0138+  0000             ptr1	= $FB
0139+  0000             ptr2	= ptr1 + 2
0140+  0000             
0141+  0000             ptr3	= $0340
0142+  0000             ptr4	= ptr3 + 2
0143+  0000             
0144+  0000             dvar1	.equ ptr4 + 2
0145+  0000             dvar2	.equ dvar1 + 2
0146+  0000             dvar3	.equ dvar2 + 2
0147+  0000             dvar4	.equ dvar3 + 2
0148+  0000             dvar5	.equ dvar4 + 2
0149+  0000             dvar6	.equ dvar5 + 2
0150+  0000             dvar7	.equ dvar6 + 2
0151+  0000             dvar8	.equ dvar7 + 2
0152+  0000             
0153+  0000             tmp1	= dvar8 + 2
0154+  0000             tmp2	= tmp1 + 1
0155+  0000             tmp3	= tmp2 + 1
0156+  0000             tmp4	= tmp3 + 1
0157+  0000             
0158+  0000             
0159+  0000             
0160+  0000             #endif
0007   0000             
0008   0000             #define ISDISKFILE
0009   0000             #include "../includes/fileHeaders.asm"
0001+  0000             #ifndef FILEHEADERS
0002+  0000             
0003+  0000             #define FILEHEADERS
0004+  0000             
0005+  0000             
0006+  0000             ;---------------------------------------------------------------
0007+  0000             ; These switches control the compilation process.
0008+  0000             ;	ONLY ONE should be uncommented at a time
0009+  0000             ;
0010+  0000             ;---------------------------------------------------------------
0011+  0000             ; These switches generate cartidge files
0012+  0000             ;
0013+  0000             ; uncomment if a VICE compatible cartridge file is
0014+  0000             ;	to be generated
0015+  0000             ;#define	EXROMVICECART
0016+  0000             ;
0017+  0000             ; uncomment if a standard cartridge file is to be
0018+  0000             ;	generated
0019+  0000             ;#define	EXROMCART
0020+  0000             ;
0021+  0000             ;---------------------------------------------------------------
0022+  0000             ; This switch generates a binary file intended to be loaded
0023+  0000             ;	at $0801 and with that load address prepended
0024+  0000             ;
0025+  0000             ;#define	ISDISKFILE
0026+  0000             
0027+  0000             
0028+  0000             I2C_CMD_REG				.equ $DF2A
0029+  0000             
0030+  0000             ; I2C commands (bits 2..0)
0031+  0000             I2CCMD_NOP				.equ $00
0032+  0000             I2CCMD_START			.equ $01
0033+  0000             I2CCMD_STOP				.equ $02
0034+  0000             I2CCMD_SEND				.equ $03
0035+  0000             I2CCMD_RXACK			.equ $04
0036+  0000             I2CCMD_RXNAK			.equ $05
0037+  0000             
0038+  0000             ; status bit masks
0039+  0000             I2CMASK_SCLPIN	    .EQU $08
0040+  0000             I2CMASK_SDAPIN		.EQU $10
0041+  0000             I2CMASK_ISIDLE		.EQU $20
0042+  0000             I2CMASK_ACKBIT		.EQU $40
0043+  0000             I2CMASK_SHFTRDY		.EQU $80
0044+  0000             
0045+  0000             
0046+  0000             I2C_DATRD_REG			.equ $DF2B
0047+  0000             I2C_DATWR_REG			.equ $DF2C
0048+  0000             
0049+  0000             eepromPtr			.equ $FB
0050+  0000             
0051+  0000             
0052+  0000             
0053+  0000             
0054+  0000             ;------------------------------------------
0055+  0000~            #ifdef EXROMVICECART
0056+  0000~            
0057+  0000~            ;this is for a 8kB cart!!
0058+  0000~            	.org $8000 - $50
0059+  0000~            
0060+  0000~            	.byte "C64 CARTRIDGE   "
0061+  0000~            	.byte $00,$00 		;header length
0062+  0000~            	.byte $00,$40 		;header length
0063+  0000~            	.word $0001 		;version
0064+  0000~            	.word $0000 		;crt type
0065+  0000~            	.byte $00 			;exrom line
0066+  0000~            	.byte $01 			;game line
0067+  0000~            	.byte $00,$00,$00,$00,$00,$00 ;unused
0068+  0000~            nameStart:
0069+  0000~            	.byte "TEST CART"
0070+  0000~            nameEnd:
0071+  0000~            	.fill (32-(nameEnd - nameStart), 0
0072+  0000~            	;chip packets
0073+  0000~            	.byte "CHIP"
0074+  0000~            	.byte $00,$00,$20,$10 ;chip length
0075+  0000~            	.byte $00,$00 ;chip type
0076+  0000~            	.byte $00,$00 ;bank
0077+  0000~            	.byte $80,$00 ;adress
0078+  0000~            	.byte $20,$00 ;length
0079+  0000~            
0080+  0000~            	.org	$8000
0081+  0000~            
0082+  0000~            	.word	coldStart					; Cartridge cold-start vector
0083+  0000~            	.word	warmStart                   ; Cartridge warm-start vector
0084+  0000~            	.byte	$C3, $C2, $CD, $38, $30		; CBM8O - Autostart key
0085+  0000~            
0086+  0000~            coldStart:
0087+  0000~            ;	KERNAL RESET ROUTINE
0088+  0000~            	stx $D016				; Turn on VIC for PAL / NTSC check
0089+  0000~            	jsr $FDA3				; IOINIT - Init CIA chips
0090+  0000~            	jsr $FD50				; RANTAM - Clear/test system RAM
0091+  0000~            	jsr $FD15				; RESTOR - Init KERNAL RAM vectors
0092+  0000~            	jsr $FF5B				; CINT   - Init VIC and screen editor
0093+  0000~            	cli						; Re-enable IRQ interrupts
0094+  0000~            
0095+  0000~            ; The following is required only if BASIC is to be used
0096+  0000~            ;	BASIC RESET  Routine
0097+  0000~            	jsr $E453				; Init BASIC RAM vectors
0098+  0000~            	jsr $E3BF				; Main BASIC RAM Init routine
0099+  0000~            	jsr $E422				; Power-up message / NEW command
0100+  0000~            	ldx #$FB
0101+  0000~            	txs						; Reduce stack pointer for BASIC
0102+  0000~            
0103+  0000~            warmStart:
0104+  0000~            
0105+  0000             #endif
0106+  0000             
0107+  0000             ;----------------------------------------------------------------------
0108+  0000~            #ifdef EXROMCART
0109+  0000~            
0110+  0000~            	.org	$8000
0111+  0000~            
0112+  0000~            	.word	coldStart					; Cartridge cold-start vector
0113+  0000~            	.word	warmStart                   ; Cartridge warm-start vector
0114+  0000~            	.byte	$C3, $C2, $CD, $38, $30		; CBM8O - Autostart key
0115+  0000~            
0116+  0000~            coldStart:
0117+  0000~            ;	KERNAL RESET ROUTINE
0118+  0000~            	stx $D016				; Turn on VIC for PAL / NTSC check
0119+  0000~            	jsr $FDA3				; IOINIT - Init CIA chips
0120+  0000~            	jsr $FD50				; RANTAM - Clear/test system RAM
0121+  0000~            	jsr $FD15				; RESTOR - Init KERNAL RAM vectors
0122+  0000~            	jsr $FF5B				; CINT   - Init VIC and screen editor
0123+  0000~            	cli						; Re-enable IRQ interrupts
0124+  0000~            
0125+  0000~            #ifdef INITBASIC
0126+  0000~            ; The following is required only if BASIC is to be used
0127+  0000~            ;	BASIC RESET  Routine
0128+  0000~            	jsr $E453				; Init BASIC RAM vectors
0129+  0000~            	jsr $E3BF				; Main BASIC RAM Init routine
0130+  0000~            	jsr $E422				; Power-up message / NEW command
0131+  0000~            #endif
0132+  0000~            
0133+  0000~            	ldx #$FB
0134+  0000~            	txs						; Reduce stack pointer for BASIC
0135+  0000~            
0136+  0000~            warmStart:
0137+  0000~            
0138+  0000             #endif
0139+  0000             
0140+  0000             ;----------------------------------------------------------------------
0141+  0000             ; A RUN header for the file
0142+  0000             
0143+  0000             
0144+  0000             #ifdef ISDISKFILE
0145+  07FF             	.org $07FF
0146+  07FF 01 08       	.db $01, $08
0147+  0801 0C 08 0A 00 	.db $0C,$08,$0A,$00,$9E,$20,$32,$30,$36,$32,$00,$00,$00
0147+  0805 9E 20 32 30 
0147+  0809 36 32 00 00 
0147+  080D 00 
0148+  080E             
0149+  080E             programEntry:
0150+  080E             
0151+  080E             #endif
0152+  080E             
0153+  080E             
0154+  080E             #endif
0010   080E             #include "../includes/fileHeaders.asm"
0001+  080E~            #ifndef FILEHEADERS
0002+  080E~            
0003+  080E~            #define FILEHEADERS
0004+  080E~            
0005+  080E~            
0006+  080E~            ;---------------------------------------------------------------
0007+  080E~            ; These switches control the compilation process.
0008+  080E~            ;	ONLY ONE should be uncommented at a time
0009+  080E~            ;
0010+  080E~            ;---------------------------------------------------------------
0011+  080E~            ; These switches generate cartidge files
0012+  080E~            ;
0013+  080E~            ; uncomment if a VICE compatible cartridge file is
0014+  080E~            ;	to be generated
0015+  080E~            ;#define	EXROMVICECART
0016+  080E~            ;
0017+  080E~            ; uncomment if a standard cartridge file is to be
0018+  080E~            ;	generated
0019+  080E~            ;#define	EXROMCART
0020+  080E~            ;
0021+  080E~            ;---------------------------------------------------------------
0022+  080E~            ; This switch generates a binary file intended to be loaded
0023+  080E~            ;	at $0801 and with that load address prepended
0024+  080E~            ;
0025+  080E~            ;#define	ISDISKFILE
0026+  080E~            
0027+  080E~            
0028+  080E~            I2C_CMD_REG				.equ $DF2A
0029+  080E~            
0030+  080E~            ; I2C commands (bits 2..0)
0031+  080E~            I2CCMD_NOP				.equ $00
0032+  080E~            I2CCMD_START			.equ $01
0033+  080E~            I2CCMD_STOP				.equ $02
0034+  080E~            I2CCMD_SEND				.equ $03
0035+  080E~            I2CCMD_RXACK			.equ $04
0036+  080E~            I2CCMD_RXNAK			.equ $05
0037+  080E~            
0038+  080E~            ; status bit masks
0039+  080E~            I2CMASK_SCLPIN	    .EQU $08
0040+  080E~            I2CMASK_SDAPIN		.EQU $10
0041+  080E~            I2CMASK_ISIDLE		.EQU $20
0042+  080E~            I2CMASK_ACKBIT		.EQU $40
0043+  080E~            I2CMASK_SHFTRDY		.EQU $80
0044+  080E~            
0045+  080E~            
0046+  080E~            I2C_DATRD_REG			.equ $DF2B
0047+  080E~            I2C_DATWR_REG			.equ $DF2C
0048+  080E~            
0049+  080E~            eepromPtr			.equ $FB
0050+  080E~            
0051+  080E~            
0052+  080E~            
0053+  080E~            
0054+  080E~            ;------------------------------------------
0055+  080E~            #ifdef EXROMVICECART
0056+  080E~            
0057+  080E~            ;this is for a 8kB cart!!
0058+  080E~            	.org $8000 - $50
0059+  080E~            
0060+  080E~            	.byte "C64 CARTRIDGE   "
0061+  080E~            	.byte $00,$00 		;header length
0062+  080E~            	.byte $00,$40 		;header length
0063+  080E~            	.word $0001 		;version
0064+  080E~            	.word $0000 		;crt type
0065+  080E~            	.byte $00 			;exrom line
0066+  080E~            	.byte $01 			;game line
0067+  080E~            	.byte $00,$00,$00,$00,$00,$00 ;unused
0068+  080E~            nameStart:
0069+  080E~            	.byte "TEST CART"
0070+  080E~            nameEnd:
0071+  080E~            	.fill (32-(nameEnd - nameStart), 0
0072+  080E~            	;chip packets
0073+  080E~            	.byte "CHIP"
0074+  080E~            	.byte $00,$00,$20,$10 ;chip length
0075+  080E~            	.byte $00,$00 ;chip type
0076+  080E~            	.byte $00,$00 ;bank
0077+  080E~            	.byte $80,$00 ;adress
0078+  080E~            	.byte $20,$00 ;length
0079+  080E~            
0080+  080E~            	.org	$8000
0081+  080E~            
0082+  080E~            	.word	coldStart					; Cartridge cold-start vector
0083+  080E~            	.word	warmStart                   ; Cartridge warm-start vector
0084+  080E~            	.byte	$C3, $C2, $CD, $38, $30		; CBM8O - Autostart key
0085+  080E~            
0086+  080E~            coldStart:
0087+  080E~            ;	KERNAL RESET ROUTINE
0088+  080E~            	stx $D016				; Turn on VIC for PAL / NTSC check
0089+  080E~            	jsr $FDA3				; IOINIT - Init CIA chips
0090+  080E~            	jsr $FD50				; RANTAM - Clear/test system RAM
0091+  080E~            	jsr $FD15				; RESTOR - Init KERNAL RAM vectors
0092+  080E~            	jsr $FF5B				; CINT   - Init VIC and screen editor
0093+  080E~            	cli						; Re-enable IRQ interrupts
0094+  080E~            
0095+  080E~            ; The following is required only if BASIC is to be used
0096+  080E~            ;	BASIC RESET  Routine
0097+  080E~            	jsr $E453				; Init BASIC RAM vectors
0098+  080E~            	jsr $E3BF				; Main BASIC RAM Init routine
0099+  080E~            	jsr $E422				; Power-up message / NEW command
0100+  080E~            	ldx #$FB
0101+  080E~            	txs						; Reduce stack pointer for BASIC
0102+  080E~            
0103+  080E~            warmStart:
0104+  080E~            
0105+  080E~            #endif
0106+  080E~            
0107+  080E~            ;----------------------------------------------------------------------
0108+  080E~            #ifdef EXROMCART
0109+  080E~            
0110+  080E~            	.org	$8000
0111+  080E~            
0112+  080E~            	.word	coldStart					; Cartridge cold-start vector
0113+  080E~            	.word	warmStart                   ; Cartridge warm-start vector
0114+  080E~            	.byte	$C3, $C2, $CD, $38, $30		; CBM8O - Autostart key
0115+  080E~            
0116+  080E~            coldStart:
0117+  080E~            ;	KERNAL RESET ROUTINE
0118+  080E~            	stx $D016				; Turn on VIC for PAL / NTSC check
0119+  080E~            	jsr $FDA3				; IOINIT - Init CIA chips
0120+  080E~            	jsr $FD50				; RANTAM - Clear/test system RAM
0121+  080E~            	jsr $FD15				; RESTOR - Init KERNAL RAM vectors
0122+  080E~            	jsr $FF5B				; CINT   - Init VIC and screen editor
0123+  080E~            	cli						; Re-enable IRQ interrupts
0124+  080E~            
0125+  080E~            #ifdef INITBASIC
0126+  080E~            ; The following is required only if BASIC is to be used
0127+  080E~            ;	BASIC RESET  Routine
0128+  080E~            	jsr $E453				; Init BASIC RAM vectors
0129+  080E~            	jsr $E3BF				; Main BASIC RAM Init routine
0130+  080E~            	jsr $E422				; Power-up message / NEW command
0131+  080E~            #endif
0132+  080E~            
0133+  080E~            	ldx #$FB
0134+  080E~            	txs						; Reduce stack pointer for BASIC
0135+  080E~            
0136+  080E~            warmStart:
0137+  080E~            
0138+  080E~            #endif
0139+  080E~            
0140+  080E~            ;----------------------------------------------------------------------
0141+  080E~            ; A RUN header for the file
0142+  080E~            
0143+  080E~            
0144+  080E~            #ifdef ISDISKFILE
0145+  080E~            	.org $07FF
0146+  080E~            	.db $01, $08
0147+  080E~            	.db $0C,$08,$0A,$00,$9E,$20,$32,$30,$36,$32,$00,$00,$00
0148+  080E~            
0149+  080E~            programEntry:
0150+  080E~            
0151+  080E~            #endif
0152+  080E~            
0153+  080E~            
0154+  080E             #endif
0011   080E             #include "../includes/kernal.asm"
0001+  080E             
0002+  080E             #ifndef lib_cbm_kernal_a
0003+  080E             #define lib_cbm_kernal_a
0004+  080E             
0005+  080E             ; Taken from the web.
0006+  080E             ; Sorry, I can't give credit because I don't have the URL anymore.
0007+  080E             ; There are alternative names for some calls.
0008+  080E             
0009+  080E             
0010+  080E             k_cint		.equ $ff81
0011+  080E             k_ioinit	.equ $ff84
0012+  080E             k_ramtas	.equ $ff87
0013+  080E             k_restor	.equ $ff8a
0014+  080E             k_vector	.equ $ff8d
0015+  080E             k_setmsg	.equ $ff90
0016+  080E             k_secnd		.equ $ff93
0017+  080E             k_tksa		.equ $ff96
0018+  080E             k_memtop	.equ $ff99
0019+  080E             k_membot	.equ $ff9c
0020+  080E             k_key		.equ $ff9f
0021+  080E             k_settmo	.equ $ffa2
0022+  080E             k_iecin		.equ $ffa5
0023+  080E             k_acptr			.equ $ffa5
0024+  080E             k_iecout	.equ $ffa8
0025+  080E             k_ciout			.equ $ffa8
0026+  080E             k_untalk	.equ $ffab
0027+  080E             k_untlk			.equ $ffab
0028+  080E             k_unlisten	.equ $ffae
0029+  080E             k_unlsn			.equ $ffae
0030+  080E             k_listen	.equ $ffb1
0031+  080E             k_listn			.equ $ffb1
0032+  080E             k_talk		.equ $ffb4
0033+  080E             k_readss	.equ $ffb7
0034+  080E             k_setlfs	.equ $ffba
0035+  080E             k_setnam	.equ $ffbd	; A is length, X is ptr-low, Y is ptr-high
0036+  080E             k_open		.equ $ffc0
0037+  080E             k_close		.equ $ffc3
0038+  080E             k_close_A		.equ $ffc3
0039+  080E             k_chkin		.equ $ffc6
0040+  080E             k_chkin_X		.equ $ffc6
0041+  080E             k_chkout	.equ $ffc9
0042+  080E             k_chkout_X		.equ $ffc9
0043+  080E             k_ckout			.equ $ffc9
0044+  080E             k_clrchn	.equ $ffcc
0045+  080E             k_clrch			.equ $ffcc
0046+  080E             k_chrin		.equ $ffcf
0047+  080E             k_basin			.equ $ffcf
0048+  080E             k_chrout	.equ $ffd2
0049+  080E             k_basout		.equ $ffd2
0050+  080E             k_bsout			.equ $ffd2
0051+  080E             k_load		.equ $ffd5
0052+  080E             k_load_AXY		.equ $ffd5	; A means verify, YYXX is desired load address (if channel == 0), returns end+1 in YYXX
0053+  080E             k_save		.equ $ffd8
0054+  080E             k_save_AXY		.equ $ffd8	; A is zp address of start ptr(!), YYXX is end address (+1)
0055+  080E             k_settim	.equ $ffdb
0056+  080E             k_rdtim		.equ $ffde
0057+  080E             k_stop		.equ $ffe1
0058+  080E             k_getin		.equ $ffe4
0059+  080E             k_get			.equ $ffe4
0060+  080E             k_clall		.equ $ffe7
0061+  080E             k_udtim		.equ $ffea
0062+  080E             k_scrorg	.equ $ffed
0063+  080E             k_plot		.equ $fff0
0064+  080E             k_plot_CXY		.equ $fff0	; get/set cursor (to set, clear carry. X/Y are y/x!)
0065+  080E             k_iobase	.equ $fff3
0066+  080E             
0067+  080E             #endif
0012   080E             
0013   080E             
0014   080E             
0015   080E             
0016   080E             entry:
0017   080E             
0018   080E             
0019   080E             
0020   080E             ; get the location of the appended data
0021   080E             ; this is a static address
0022   080E A9 09       	lda	#(fileStart & $FF)
0023   0810 85 FB       	sta	ptr1
0024   0812 A9 0B       	lda	#(fileStart >> 8)
0025   0814 85 FC       	sta ptr1 + 1
0026   0816             
0027   0816             ; the number of 256 byte blocks
0028   0816 AD 02 0B    	lda fileLenL + 1
0029   0819 8D 44 03    	sta	dvar1
0030   081C AD 03 0B    	lda fileLenL + 2
0031   081F 8D 45 03    	sta dvar1 + 1
0032   0822             
0033   0822             ; the eeprom address
0034   0822 AD 05 0B    	lda eepAdrL
0035   0825 8D 46 03    	sta	dvar2
0036   0828 AD 06 0B    	lda eepAdrL + 1
0037   082B 8D 47 03    	sta	dvar2 + 1
0038   082E AD 07 0B    	lda eepAdrH
0039   0831 8D 48 03    	sta	dvar3
0040   0834             
0041   0834 20 62 08    	jsr	printBanner
0042   0837 20 AC 08    	jsr printEepAdr
0043   083A 20 CB 08    	jsr printFileLen
0044   083D 20 72 08    	jsr printYN
0045   0840 20 8B 08    	jsr	waitkey
0046   0843 C9 59       	cmp	#'Y'
0047   0845 F0 0B       	beq	doPgm
0048   0847 C9 79       	cmp #'y'
0049   0849 F0 07       	beq	doPgm
0050   084B             
0051   084B             ; user wants to exit
0052   084B 20 EA 08    	jsr	printCRLF
0053   084E 20 F0 08    	jsr	printPgmEnd
0054   0851 60          	rts
0055   0852             
0056   0852             doPgm:
0057   0852 20 EA 08    	jsr printCRLF
0058   0855 20 77 09    	jsr eepWriteBlock
0059   0858 20 EA 08    	jsr	printCRLF
0060   085B 20 6A 08    	jsr printByebye
0061   085E 20 F0 08    	jsr	printPgmEnd
0062   0861 60          	rts
0063   0862             
0064   0862             
0065   0862             
0066   0862             printBanner:
0067   0862 A9 F8       	lda #(banner & 255)
0068   0864 A2 08       	ldx	#(banner >> 8)
0069   0866 20 7A 08    	jsr	printAsciiz
0070   0869 60          	rts
0071   086A             
0072   086A             printByebye:
0073   086A A9 0F       	lda #(byebye & 255)
0074   086C A2 09       	ldx	#(byebye >> 8)
0075   086E 20 7A 08    	jsr	printAsciiz
0076   0871 60          	rts
0077   0872             
0078   0872             printYN:
0079   0872 A9 4B       	lda #(msg3 & 255)
0080   0874 A2 09       	ldx	#(msg3 >> 8)
0081   0876 20 7A 08    	jsr	printAsciiz
0082   0879 60          	rts
0083   087A             
0084   087A             
0085   087A             printAsciiz:
0086   087A 85 FD       	sta	ptr2
0087   087C 86 FE       	stx	ptr2 + 1
0088   087E A0 00       	ldy	#$00
0089   0880             printAsciizLoop:
0090   0880 B1 FD       	lda	(ptr2), y
0091   0882 F0 06       	beq	printAsciizExit
0092   0884 20 D2 FF    	jsr	k_chrout
0093   0887 C8          	iny
0094   0888 D0 F6       	bne printAsciizLoop
0095   088A             printAsciizExit:
0096   088A 60          	rts
0097   088B             
0098   088B             waitkey:
0099   088B 20 E4 FF    	jsr	k_getin
0100   088E F0 FB       	beq waitkey
0101   0890 60          	rts
0102   0891             
0103   0891             ; print the value in A in hex
0104   0891             ;	at the current cursor position
0105   0891             printAHex:
0106   0891 8D 55 03    	sta	tmp2
0107   0894 4A          	lsr	a
0108   0895 4A          	lsr a
0109   0896 4A          	lsr a
0110   0897 4A          	lsr a
0111   0898 AA          	tax
0112   0899 BD 67 09    	lda	hexDigits, x
0113   089C 20 D2 FF    	jsr	k_chrout
0114   089F AD 55 03    	lda	tmp2
0115   08A2 29 0F       	and #$0F
0116   08A4 AA          	tax
0117   08A5 BD 67 09    	lda	hexDigits, x
0118   08A8 20 D2 FF    	jsr	k_chrout
0119   08AB 60          	rts
0120   08AC             
0121   08AC             printEepAdr:
0122   08AC A9 21       	lda #(msg1 & 255)
0123   08AE A2 09       	ldx	#(msg1 >> 8)
0124   08B0 20 7A 08    	jsr	printAsciiz
0125   08B3             
0126   08B3 AD 48 03    	lda	dvar3
0127   08B6 20 91 08    	jsr printAHex
0128   08B9 AD 47 03    	lda	dvar2 + 1
0129   08BC 20 91 08    	jsr printAHex
0130   08BF AD 46 03    	lda	dvar2
0131   08C2 20 91 08    	jsr printAHex
0132   08C5 A9 0D       	lda #$0D
0133   08C7 20 D2 FF    	jsr	k_chrout
0134   08CA 60          	rts
0135   08CB             
0136   08CB             printFileLen:
0137   08CB A9 33       	lda #(msg2 & 255)
0138   08CD A2 09       	ldx	#(msg2 >> 8)
0139   08CF 20 7A 08    	jsr	printAsciiz
0140   08D2             
0141   08D2 AD 45 03    	lda	dvar1 + 1
0142   08D5 20 91 08    	jsr printAHex
0143   08D8 AD 44 03    	lda	dvar1
0144   08DB 20 91 08    	jsr printAHex
0145   08DE A9 0D       	lda #$0D
0146   08E0 20 D2 FF    	jsr	k_chrout
0147   08E3 60          	rts
0148   08E4             
0149   08E4             printDot:
0150   08E4 A9 2E       	lda	#'.'
0151   08E6 20 D2 FF    	jsr	k_chrout
0152   08E9 60          	rts
0153   08EA             
0154   08EA             printCRLF:
0155   08EA A9 0D       	lda	#$0D
0156   08EC 20 D2 FF    	jsr	k_chrout
0157   08EF 60          	rts
0158   08F0             
0159   08F0             printPgmEnd:
0160   08F0 A9 5A       	lda #(exitStr & 255)
0161   08F2 A2 09       	ldx	#(exitStr >> 8)
0162   08F4 20 7A 08    	jsr	printAsciiz
0163   08F7 60          	rts
0164   08F8             
0165   08F8             
0166   08F8             
0167   08F8             banner:
0168   08F8 45 45 50 52 	.byte "EEPROM PROGRAMER V1.0", $0D, $00
0168   08FC 4F 4D 20 50 
0168   0900 52 4F 47 52 
0168   0904 41 4D 45 52 
0168   0908 20 56 31 2E 
0168   090C 30 0D 00 
0169   090F             byebye:
0170   090F 45 45 50 52 	.byte "EEPROM PROGRAMED", $0D, $00
0170   0913 4F 4D 20 50 
0170   0917 52 4F 47 52 
0170   091B 41 4D 45 44 
0170   091F 0D 00 
0171   0921             
0172   0921             
0173   0921             msg1:
0174   0921 45 45 50 52 	.byte "EEPROM ADDRESS: $", $00
0174   0925 4F 4D 20 41 
0174   0929 44 44 52 45 
0174   092D 53 53 3A 20 
0174   0931 24 00 
0175   0933             msg2:
0176   0933 46 49 4C 45 	.byte "FILE LENGTH (BLOCKS): $", $00
0176   0937 20 4C 45 4E 
0176   093B 47 54 48 20 
0176   093F 28 42 4C 4F 
0176   0943 43 4B 53 29 
0176   0947 3A 20 24 00 
0177   094B             msg3:
0178   094B 43 4F 4E 54 	.byte "CONTINUE (Y/N)", $00
0178   094F 49 4E 55 45 
0178   0953 20 28 59 2F 
0178   0957 4E 29 00 
0179   095A             exitStr:
0180   095A 50 52 4F 47 	.byte "PROGRAM END", $0D, $00
0180   095E 52 41 4D 20 
0180   0962 45 4E 44 0D 
0180   0966 00 
0181   0967             
0182   0967             
0183   0967             
0184   0967             hexDigits:
0185   0967 30 31 32 33 	.byte "0123456789ABCDEF"
0185   096B 34 35 36 37 
0185   096F 38 39 41 42 
0185   0973 43 44 45 46 
0186   0977             
0187   0977             
0188   0977             #include "../includes/eepRtns.asm"
0001+  0977             
0002+  0977             
0003+  0977             
0004+  0977             
0005+  0977             ;----------------------------------------
0006+  0977             ; Write a block of data to the EEPROM.
0007+  0977             ;	This routine assumes that we are writing
0008+  0977             ;	complete 256 byte blocks and that the write
0009+  0977             ;	address is on a 256 byte boundary.
0010+  0977             ;
0011+  0977             ; We do no verification to ensure that data
0012+  0977             ;	is not corrupted, so caveat emptor
0013+  0977             ;
0014+  0977             ; Inputs:
0015+  0977             ;	ptr1			address of buffer which has
0016+  0977             ;						data to be written
0017+  0977             ;	dvar1			the number of 256 byte blocks
0018+  0977             ;						to write
0019+  0977             ;	dvar3:dvar2		the EEPROM write address (24 bits)
0020+  0977             ;
0021+  0977             ;
0022+  0977             
0023+  0977             eepWriteBlock:
0024+  0977             
0025+  0977             ;
0026+  0977             ; check so see if the EEPROM write address is
0027+  0977             ;	an even multiple of 256. exit with an
0028+  0977             ;	error to prevent toatlly messing up
0029+  0977             ;	the EEPROM.
0030+  0977             ;
0031+  0977 AD 46 03    	lda dvar2
0032+  097A D0 6B       	bne	eepWrError
0033+  097C             
0034+  097C             ;
0035+  097C             ; is the number of blocks to move between
0036+  097C             ;	$001 and $800 inclusive?
0037+  097C             
0038+  097C             ; check for zero blocks to move
0039+  097C AD 44 03    	lda	dvar1
0040+  097F 0D 45 03    	ora	dvar1 + 1
0041+  0982 F0 65       	beq eepWrOK		; silently exit after moving nothing
0042+  0984             
0043+  0984 38          	sec
0044+  0985 AD 44 03    	lda dvar1
0045+  0988 E9 01       	sbc #$01
0046+  098A AD 45 03    	lda	dvar1+1
0047+  098D E9 08       	sbc #$08
0048+  098F B0 56       	bcs	eepWrError
0049+  0991             
0050+  0991             
0051+  0991             eepWriteBlockLoop1:
0052+  0991             
0053+  0991             #ifdef EEPRTN_PRINTDOT
0054+  0991 20 E4 08    	jsr	printDot
0055+  0994             #endif
0056+  0994             
0057+  0994~            #ifdef EEPRTN_WAITKEY
0058+  0994~            	jsr	waitkey
0059+  0994             #endif
0060+  0994             
0061+  0994             
0062+  0994 20 3C 0A    	jsr eepMakeSlaveAdr
0063+  0997 20 4D 0A    	jsr i2cSendStart
0064+  099A             
0065+  099A             ; send the address at which to write
0066+  099A             ;
0067+  099A             ; send the slave address
0068+  099A AD 49 03    	lda dvar3 + 1
0069+  099D 20 69 0A    	jsr i2cSendByte
0070+  09A0 D0 45       	bne	eepWrError		; no ACK from the EEPROM
0071+  09A2             
0072+  09A2 AD 47 03    	lda	dvar2 + 1
0073+  09A5 20 69 0A    	jsr i2cSendByte
0074+  09A8 D0 3D       	bne	eepWrError		; no ACK from the EEPROM
0075+  09AA             
0076+  09AA AD 46 03    	lda	dvar2
0077+  09AD 20 69 0A    	jsr i2cSendByte
0078+  09B0 D0 35       	bne	eepWrError		; no ACK from the EEPROM
0079+  09B2             
0080+  09B2             ; send 256 bytes
0081+  09B2 A9 00       	lda	#$00
0082+  09B4 8D 54 03    	sta	tmp1
0083+  09B7             
0084+  09B7 20 80 0A    	jsr	i2cSendNBytes
0085+  09BA 20 5C 0A    	jsr i2cSendStop
0086+  09BD             
0087+  09BD A9 01       	lda #$01
0088+  09BF 8D 2E DF    	sta	$DF2E
0089+  09C2             
0090+  09C2             ;	ldx	#$00
0091+  09C2             ;	jsr	eepWriteBlockWaitWr
0092+  09C2             ;	bne	eepWrError
0093+  09C2             
0094+  09C2 20 EA 09    	jsr eepWait15ms
0095+  09C5             
0096+  09C5 A9 00       	lda #$00
0097+  09C7 8D 2E DF    	sta	$DF2E
0098+  09CA             
0099+  09CA             
0100+  09CA             
0101+  09CA             ; increment the EEPROM page number
0102+  09CA EE 47 03    	inc dvar2 + 1
0103+  09CD D0 03       	bne	eepWB1
0104+  09CF EE 48 03    	inc	dvar3
0105+  09D2             eepWB1:
0106+  09D2             
0107+  09D2             ; increment the buffer pointer 256 bytes
0108+  09D2 E6 FC       	inc	ptr1 + 1
0109+  09D4             
0110+  09D4             ; decrement the block count and check against zero
0111+  09D4 AD 44 03    	lda	dvar1
0112+  09D7 D0 08       	bne	eepWB2
0113+  09D9 AD 45 03    	lda	dvar1 + 1
0114+  09DC F0 0B       	beq eepWrOK		; no more blocks left, so exit
0115+  09DE CE 45 03    	dec dvar1 + 1
0116+  09E1             eepWB2:
0117+  09E1 CE 44 03    	dec	dvar1
0118+  09E4 4C 91 09    	jmp eepWriteBlockLoop1
0119+  09E7             
0120+  09E7             
0121+  09E7             
0122+  09E7             eepWrError:
0123+  09E7 A9 FF       	lda #$FF
0124+  09E9             eepWrOK:
0125+  09E9 60          	rts
0126+  09EA             
0127+  09EA             
0128+  09EA             eepWait15ms:
0129+  09EA A2 C4       	ldx	#$C4
0130+  09EC A9 09       	lda	#$09
0131+  09EE             
0132+  09EE             ;------------------------------------------------------------
0133+  09EE             ;Constant time decrement
0134+  09EE             ;6 cycles
0135+  09EE             ;A = high byte, X = low byte
0136+  09EE             ;Underflow (decrementing to $FFFF) clears the carry
0137+  09EE             eepWait15msLoop:
0138+  09EE E0 01       	CPX #$01
0139+  09F0 CA          	DEX
0140+  09F1 E9 00       	SBC #$00
0141+  09F3 B0 F9       	bcs	eepWait15msLoop
0142+  09F5 60          	rts
0143+  09F6             
0144+  09F6             
0145+  09F6             
0146+  09F6             
0147+  09F6             
0148+  09F6             ;----------------------------------------
0149+  09F6             ; Wait for a buffer write to complete
0150+  09F6             ; 	The EEPROM may take up to 10ms to
0151+  09F6             ;	complete writing its data buffer to
0152+  09F6             ;	the array but it may complete im
0153+  09F6             ;	much less time. The EEPROM allows
0154+  09F6             ;	a polling operation to be used to
0155+  09F6             ;	determine if the write is complete.
0156+  09F6             ;
0157+  09F6             ;	The polling sends the slave address
0158+  09F6             ;	to the EEPROM and looks for an ACK
0159+  09F6             ;	fom the chip. If the ACK comes back,
0160+  09F6             ;	the write is compete and we can
0161+  09F6             ;	move on. If no ACK is received after
0162+  09F6             ;	a number of retries, we declare an
0163+  09F6             ;	error and return
0164+  09F6             ;
0165+  09F6             eepWriteBlockWaitWr:
0166+  09F6 20 4D 0A    	jsr i2cSendStart
0167+  09F9             ; send the slave address
0168+  09F9 AD 49 03    	lda dvar3 + 1
0169+  09FC 20 69 0A    	jsr i2cSendByte
0170+  09FF F0 06       	beq	eepWriteBlockWaitWr1		; got an ACK from the EEPROM
0171+  0A01 CA          	dex								; decrement the retry counter
0172+  0A02 D0 F2       	bne eepWriteBlockWaitWr			; back to try again
0173+  0A04 A9 FF       	lda	#$FF
0174+  0A06 60          	rts
0175+  0A07             eepWriteBlockWaitWr1:
0176+  0A07 20 5C 0A    	jsr	i2cSendStop
0177+  0A0A A9 00       	lda	#$00
0178+  0A0C 60          	rts
0179+  0A0D             
0180+  0A0D             
0181+  0A0D             
0182+  0A0D             
0183+  0A0D             ;----------------------------------------
0184+  0A0D             ; Read a block of data from the EEPROM
0185+  0A0D             ;
0186+  0A0D             ; Inputs:
0187+  0A0D             ;----------------------------------------
0188+  0A0D             ; These two variables are in the position
0189+  0A0D             ;	required by the i2cGetNBytes subroutine
0190+  0A0D             ;
0191+  0A0D             ;	ptr1	address of buffer into which
0192+  0A0D             ;				data is to be written
0193+  0A0D             ;	dvar1	lengeh of data to be read
0194+  0A0D             ;				65536 bytes maximum
0195+  0A0D             ;----------------------------------------
0196+  0A0D             ;
0197+  0A0D             ;	dvar3:dvar2		EEPROM read address (24 bits)
0198+  0A0D             ;
0199+  0A0D             eepReadBlock:
0200+  0A0D 20 4D 0A    	jsr i2cSendStart
0201+  0A10             
0202+  0A10             ; form the slave address and send the
0203+  0A10             ;	high 3 bits of the read address
0204+  0A10             ;
0205+  0A10 20 3C 0A    	jsr eepMakeSlaveAdr
0206+  0A13             
0207+  0A13 20 69 0A    	jsr i2cSendByte
0208+  0A16 D0 20       	bne	eepRdError		; no ACK from the EEPROM
0209+  0A18             
0210+  0A18 AD 47 03    	lda	dvar2 + 1
0211+  0A1B 20 69 0A    	jsr i2cSendByte
0212+  0A1E D0 18       	bne	eepRdError		; no ACK from the EEPROM
0213+  0A20             
0214+  0A20 AD 46 03    	lda	dvar2
0215+  0A23 20 69 0A    	jsr i2cSendByte
0216+  0A26 D0 10       	bne	eepRdError		; no ACK from the EEPROM
0217+  0A28             
0218+  0A28 20 4D 0A    	jsr i2cSendStart
0219+  0A2B             
0220+  0A2B AD 49 03    	lda	dvar3 + 1		; get the slave address
0221+  0A2E 09 01       	ora #$01			; set the read mode bit
0222+  0A30 20 69 0A    	jsr i2cSendByte		; re-send the slave address
0223+  0A33 D0 03       	bne	eepRdError		; no ACK from the EEPROM
0224+  0A35             
0225+  0A35             ; read the bytes
0226+  0A35 20 C1 0A    	jsr i2cGetNBytes
0227+  0A38             eepRdError:
0228+  0A38 20 5C 0A    	jsr i2cSendStop
0229+  0A3B 60          	rts
0230+  0A3C             
0231+  0A3C             
0232+  0A3C             ;----------------------------------------
0233+  0A3C             ; Make the slave address from the value in
0234+  0A3C             ;	the EEPROM address registers
0235+  0A3C             ;
0236+  0A3C             ;	dvar3:dvar2		EEPROM read address (24 bits)
0237+  0A3C             ;
0238+  0A3C             eepMakeSlaveAdr:
0239+  0A3C             ;	set up the slave address for future use
0240+  0A3C AD 48 03    	lda dvar3
0241+  0A3F 29 07       	and #07
0242+  0A41 8D 48 03    	sta	dvar3
0243+  0A44 0A          	asl	a
0244+  0A45 29 FE       	and #$FE
0245+  0A47 09 A0       	ora	#$A0
0246+  0A49 8D 49 03    	sta dvar3 + 1		; save for later
0247+  0A4C 60          	rts
0248+  0A4D             
0189   0A4D             #include "../includes/i2cRtnsX.asm"
0001+  0A4D             
0002+  0A4D             ;#include "reuPlusDefs.asm"
0003+  0A4D             
0004+  0A4D             
0005+  0A4D             ; ---------------------------------------------------------------
0006+  0A4D             ; Send an I2C START command
0007+  0A4D             ;
0008+  0A4D             ; Inputs:
0009+  0A4D             ;	None
0010+  0A4D             ;
0011+  0A4D             ; Outputs:
0012+  0A4D             ;	None
0013+  0A4D             ;
0014+  0A4D             ; Registers affected:
0015+  0A4D             ;	All
0016+  0A4D             ; ---------------------------------------------------------------
0017+  0A4D             i2cSendStart:
0018+  0A4D             ;
0019+  0A4D             ; initiate the START command
0020+  0A4D A9 01       	lda		#I2C_CMDSTART
0021+  0A4F 8D 2A DF    	sta		I2C_CMDREG
0022+  0A52             
0023+  0A52             ; the I2C FSM will reset the command to
0024+  0A52             ;	I2C_CMDNOP when it is done
0025+  0A52             L0001:
0026+  0A52 AD 2A DF    	lda		I2C_CMDREG
0027+  0A55 29 07       	and		#I2C_MASK_CMDBITS
0028+  0A57 C9 00       	cmp		#I2C_CMDNOP
0029+  0A59 D0 F7       	bne		L0001
0030+  0A5B 60          	rts
0031+  0A5C             
0032+  0A5C             
0033+  0A5C             ; ---------------------------------------------------------------
0034+  0A5C             ; Send an I2C STOP command
0035+  0A5C             ;
0036+  0A5C             ; Inputs:
0037+  0A5C             ;	None
0038+  0A5C             ;
0039+  0A5C             ; Outputs:
0040+  0A5C             ;	None
0041+  0A5C             ;
0042+  0A5C             ; Registers affected:
0043+  0A5C             ;	All
0044+  0A5C             ; ---------------------------------------------------------------
0045+  0A5C             
0046+  0A5C             i2cSendStop:
0047+  0A5C             
0048+  0A5C             ; initiate the STOP command
0049+  0A5C A9 02       	lda		#I2C_CMDSTOP
0050+  0A5E 8D 2A DF    	sta		I2C_CMDREG
0051+  0A61             
0052+  0A61             ; the I2C FSM will reset the command to
0053+  0A61             ;	I2C_CMDNOP when it is done
0054+  0A61             L0002:
0055+  0A61 AD 2A DF    	lda		I2C_CMDREG
0056+  0A64 29 07       	and		#I2C_MASK_CMDBITS
0057+  0A66 D0 F9       	bne		L0002
0058+  0A68 60          	rts
0059+  0A69             
0060+  0A69             ; ---------------------------------------------------------------
0061+  0A69             ; Send one byte over the I2C bus. This routine returns the state
0062+  0A69             ;	of the ACK bit
0063+  0A69             ;
0064+  0A69             ; Inputs:
0065+  0A69             ;	A	byte to send
0066+  0A69             ;
0067+  0A69             ; Outputs:
0068+  0A69             ;	A	$00 - ACK received, else ACK not received
0069+  0A69             ;
0070+  0A69             ; Registers affected:
0071+  0A69             ;	All
0072+  0A69             ;
0073+  0A69             ; ---------------------------------------------------------------
0074+  0A69             
0075+  0A69             i2cSendByte:
0076+  0A69 A2 03       	ldx		#I2C_CMDSEND
0077+  0A6B 8E 2A DF    	stx		I2C_CMDREG
0078+  0A6E             
0079+  0A6E             i2cSendByteN:
0080+  0A6E 8D 2C DF    	sta		I2C_DATWRREG
0081+  0A71             
0082+  0A71             L0003:
0083+  0A71 AD 2A DF    	lda		I2C_CMDREG
0084+  0A74 29 80       	and		#I2C_MASK_SFTRDY
0085+  0A76 F0 F9       	beq		L0003
0086+  0A78             
0087+  0A78 A2 00       	ldx		#$00
0088+  0A7A AD 2A DF    	lda		I2C_CMDREG
0089+  0A7D 29 40       	and		#I2C_MASK_ACKBIT
0090+  0A7F 60          	rts
0091+  0A80             
0092+  0A80             
0093+  0A80             ; ---------------------------------------------------------------
0094+  0A80             ; Send N bytes (up to 256) over the I2C bus.
0095+  0A80             ;
0096+  0A80             ; Inputs:
0097+  0A80             ;	tmp1	number of bytes to send
0098+  0A80             ;	ptr1	send buffer address
0099+  0A80             ;
0100+  0A80             ; Outputs:
0101+  0A80             ;	A	$00 - all is OK, else an error occurred during the transfer
0102+  0A80             ;
0103+  0A80             ; Registers affected:
0104+  0A80             ;	All
0105+  0A80             ;	ptr1
0106+  0A80             ;
0107+  0A80             ; ---------------------------------------------------------------
0108+  0A80             ;
0109+  0A80             i2cSendNBytes:
0110+  0A80             
0111+  0A80             ; set up the I2C controller
0112+  0A80 A9 03       	lda		#I2C_CMDSEND
0113+  0A82 8D 2A DF    	sta		I2C_CMDREG
0114+  0A85             
0115+  0A85             ; (ptr1), y will now point to the first
0116+  0A85             ; bytes to be transferred
0117+  0A85 A0 00       	ldy		#$00
0118+  0A87             
0119+  0A87             L0004B:
0120+  0A87             ; get a data byte to send
0121+  0A87 B1 FB       	lda		(ptr1), y
0122+  0A89             ; send it
0123+  0A89 20 6E 0A    	jsr 	i2cSendByteN
0124+  0A8C D0 08       	bne		L0004A	; there is an error
0125+  0A8E             
0126+  0A8E             ; next byte
0127+  0A8E C8          	iny
0128+  0A8F             ; update the byte counter
0129+  0A8F CE 54 03    	dec		tmp1
0130+  0A92             ; back around for more bytes.
0131+  0A92 D0 F3       	bne		L0004B
0132+  0A94             
0133+  0A94 A9 00       	lda		#$00
0134+  0A96             L0004A:
0135+  0A96 A2 00       	ldx		#$00
0136+  0A98 60          	rts
0137+  0A99             
0138+  0A99             ; ---------------------------------------------------------------
0139+  0A99             ; Receive one byte on the I2C bus and respond with an ACK
0140+  0A99             ;
0141+  0A99             ; Inputs:
0142+  0A99             ;	None
0143+  0A99             ;
0144+  0A99             ; Outputs:
0145+  0A99             ;	A	the byte received
0146+  0A99             ;
0147+  0A99             ; Registers affected
0148+  0A99             ;	All
0149+  0A99             ; ---------------------------------------------------------------
0150+  0A99             ;
0151+  0A99             i2cGetByteAck:
0152+  0A99             
0153+  0A99 A2 04       	ldx		#I2C_CMDRXACK
0154+  0A9B 8E 2A DF    	stx		I2C_CMDREG
0155+  0A9E             
0156+  0A9E             i2cGetByteAckN:
0157+  0A9E AD 2B DF    	lda		I2C_DATRDREG
0158+  0AA1 AA          	tax
0159+  0AA2             
0160+  0AA2             L0005:
0161+  0AA2 AD 2A DF    	lda		I2C_CMDREG
0162+  0AA5 29 80       	and		#I2C_MASK_SFTRDY
0163+  0AA7 F0 F9       	beq		L0005
0164+  0AA9             
0165+  0AA9 8A          	txa
0166+  0AAA A2 00       	ldx		#$00
0167+  0AAC 60          	rts
0168+  0AAD             
0169+  0AAD             
0170+  0AAD             ; ---------------------------------------------------------------
0171+  0AAD             ; Receive one byte on the I2C bus and respond with an NACK
0172+  0AAD             ;
0173+  0AAD             ; Inputs:
0174+  0AAD             ;	None
0175+  0AAD             ;
0176+  0AAD             ; Outputs:
0177+  0AAD             ;	A	the byte received
0178+  0AAD             ;
0179+  0AAD             ; Registers affected
0180+  0AAD             ;	All
0181+  0AAD             ; ---------------------------------------------------------------
0182+  0AAD             
0183+  0AAD             i2cGetByteNack:
0184+  0AAD             
0185+  0AAD A2 05       	ldx		#I2C_CMDRXNACK
0186+  0AAF 8E 2A DF    	stx		I2C_CMDREG
0187+  0AB2 AD 2B DF    	lda		I2C_DATRDREG
0188+  0AB5 AA          	tax
0189+  0AB6             
0190+  0AB6             L0005GBN:
0191+  0AB6 AD 2A DF    	lda		I2C_CMDREG
0192+  0AB9 29 80       	and		#I2C_MASK_SFTRDY
0193+  0ABB F0 F9       	beq		L0005GBN
0194+  0ABD             
0195+  0ABD 8A          	txa
0196+  0ABE A2 00       	ldx		#$00
0197+  0AC0 60          	rts
0198+  0AC1             
0199+  0AC1             
0200+  0AC1             ; ---------------------------------------------------------------
0201+  0AC1             ; Get N bytes over the I2C bus.
0202+  0AC1             ;
0203+  0AC1             ; Inputs:
0204+  0AC1             ;	ptr1			Pointer to the receive buffer
0205+  0AC1             ;	ptr4			The byte count (65536 bytes max)
0206+  0AC1             ;
0207+  0AC1             ; Outputs:
0208+  0AC1             ;	A	$00 - all is OK, else an error occurred during the transfer
0209+  0AC1             ;
0210+  0AC1             ; Registers affected:
0211+  0AC1             ;	All
0212+  0AC1             ;	ptr1
0213+  0AC1             ;
0214+  0AC1             ; ---------------------------------------------------------------
0215+  0AC1             ;
0216+  0AC1             i2cGetNBytes:
0217+  0AC1             
0218+  0AC1             ; set up the I2C controller
0219+  0AC1 A9 04       	lda		#I2C_CMDRXACK
0220+  0AC3 8D 2A DF    	sta		I2C_CMDREG
0221+  0AC6             
0222+  0AC6             ; do a dummy read. this shifts in the first
0223+  0AC6             ; actual data byte from the I2C peripheral
0224+  0AC6 20 9E 0A    	jsr		i2cGetByteAckN
0225+  0AC9             
0226+  0AC9             ; (ptr1), y will now point to buffer location
0227+  0AC9             ; where the read byte will be put
0228+  0AC9 A0 00       	ldy		#$00
0229+  0ACB             
0230+  0ACB             L0006B:
0231+  0ACB             ; decrement the byte count and check if it
0232+  0ACB             ;	is zero
0233+  0ACB AD 42 03    	lda		ptr4
0234+  0ACE D0 08       	bne 	i2cGNBdecbc
0235+  0AD0 AD 43 03    	lda		ptr4 + 1
0236+  0AD3 F0 14       	beq 	exit			; the byte counter is zero, so we are done
0237+  0AD5 CE 43 03    	dec		ptr4 + 1
0238+  0AD8             i2cGNBdecbc:
0239+  0AD8 CE 42 03    	dec 	ptr4
0240+  0ADB             
0241+  0ADB             ; read the byte in the I2C FSM receive register
0242+  0ADB             ; and get the next
0243+  0ADB 20 9E 0A    	jsr 	i2cGetByteAckN
0244+  0ADE 91 FB       	sta		(ptr1), y
0245+  0AE0             
0246+  0AE0             ; increment the buffer pointer
0247+  0AE0 E6 FB       	inc 	ptr1
0248+  0AE2 D0 02       	bne		i2cGNBincptr
0249+  0AE4 E6 FC       	inc		ptr1+1
0250+  0AE6             i2cGNBincptr:
0251+  0AE6             
0252+  0AE6             
0253+  0AE6             
0254+  0AE6             ; back around for more bytes.
0255+  0AE6 4C CB 0A    	jmp		L0006B
0256+  0AE9             
0257+  0AE9             exit:
0258+  0AE9             ; do a dummy read with a NACK to end the transaction
0259+  0AE9 20 AD 0A    	jsr		i2cGetByteNack
0260+  0AEC A9 00       	lda		#$00
0261+  0AEE A2 00       	ldx		#$00
0262+  0AF0             
0263+  0AF0 60          	rts
0264+  0AF1             
0265+  0AF1             
0190   0AF1             
0191   0AF1             ; this provides some safety space to avoid
0192   0AF1             ;	munging either the program or the
0193   0AF1             ;	succeeding variables
0194   0AF1             
0195   0AF1 00 00 00 00 	.fill 16, 0
0195   0AF5 00 00 00 00 
0195   0AF9 00 00 00 00 
0195   0AFD 00 00 00 00 
0196   0B01             fileLenL:
0197   0B01 00 01       	.word	$0100
0198   0B03             fileLenH:
0199   0B03 00 00       	.word	$0000
0200   0B05             
0201   0B05             ; only 16 of these bits are actually used.
0202   0B05             ;	the highest byte is ignored and the lowest
0203   0B05             ;	byte is assumed to be zero and so is
0204   0B05             ;	also ignored.
0205   0B05             eepAdrL
0206   0B05 00 00       	.word	$0000
0207   0B07             eepAdrH
0208   0B07 00 00       	.word	$0000
0209   0B09             
0210   0B09             ; this is where the code to be written to
0211   0B09             ;	the EEPROM will be concatenated
0212   0B09             
0213   0B09             fileStart:
0214   0B09             
0215   0B09             	.end
tasm: Number of errors = 0
