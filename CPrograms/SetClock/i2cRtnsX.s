;
; File generated by cc65 v 2.18 - Git bf4b195
;
	.fopt		compiler,"cc65 v 2.18 - Git bf4b195"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		_i2cSendStart
	.export		_i2cSendStop
	.export		_i2cSendByte
	.export		_i2cSendNBytes
	.export		_i2cGetByteAck
	.export		_i2cGetByteNack
	.export		_i2cGetNBytes

; export locally defined globals
;	.export		_workByte
;	.export		_errCode

; an external global
	.import		_rtcDat

	.import		_g_rtcStartAdr
	.import		_g_rtcNrBytes
	.import		_g_rtcAryPtr
	.import		_g_rtcRegs	; [20]




; place globals in this section
.segment	"BSS"

;_workByte:
;	.res	1,$00



I2C_DATWRREG	= $DF2C
I2C_DATRDREG	= $DF2B
I2C_CMDREG	= $DF2A
I2C_CMDNOP	= $00
I2C_CMDSTART	= $01
I2C_CMDSTOP	= $02
I2C_CMDSEND	= $03
I2C_CMDRXACK	= $04
I2C_CMDRXNACK	= $05
I2C_MASK_SFTRDY = $80
I2C_MASK_ACKBIT = $40
I2C_MASK_CMDBITS = $07



; ---------------------------------------------------------------
; void __near__ i2cSendStart (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cSendStart: near

.segment	"CODE"

; initiate the START command
	lda	#I2C_CMDSTART
	sta	I2C_CMDREG

; the I2C FSM will reset the command to
;	I2C_CMDNOP when it is done
L0001:
	lda	I2C_CMDREG
	and	#I2C_MASK_CMDBITS
	cmp	#I2C_CMDNOP
	bne	L0001
	ldx	#$00
	rts

.endproc


; ---------------------------------------------------------------
; void __near__ i2cSendStop (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cSendStop: near

.segment	"CODE"

; initiate the STOP command
	lda	#I2C_CMDSTOP
	sta	I2C_CMDREG

; the I2C FSM will reset the command to
;	I2C_CMDNOP when it is done
L0002:

	lda	I2C_CMDREG
	and	#I2C_MASK_CMDBITS
	bne	L0002
	ldx	#$00
	rts

.endproc


; ---------------------------------------------------------------
; unsigned char __near__ i2cSendByte (unsigned char byte)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cSendByte: near

.segment	"CODE"

	ldx	#I2C_CMDSEND
	stx	I2C_CMDREG
	sta	I2C_DATWRREG

L0003:
	lda	I2C_CMDREG
	and	#I2C_MASK_SFTRDY
	beq	L0003

	lda	I2C_CMDREG
	and	#I2C_MASK_ACKBIT
	ldx	#$00
	rts

.endproc



; ---------------------------------------------------------------
; unsigned char __near__ i2cSendNBytes (unsigned char nrBytes, unsigned int bufAdr)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cSendNBytes: near

.segment	"CODE"

; save the passed address to a safe place
; CC65 has these for our use
;
	sta	ptr1
	stx	ptr1 + 1

; set up the I2C controller
	lda	#I2C_CMDSEND
	sta	I2C_CMDREG

; get the number of bytes to transfer
	ldy     #$00
	lda	(sp), y
	tax

; (ptr1), y will now point to the first
; bytes to be transferred
        ldy	#$00

L0004B:
; get a data byte to send
	lda	(ptr1), y
; send it
	sta	I2C_DATWRREG

; wait for the shifter to be ready
L0004:
	lda	I2C_CMDREG
	and	#I2C_MASK_SFTRDY
	beq	L0004
; the byte has been sent, so check the acknowledge bit
	lda	I2C_CMDREG
	and	#I2C_MASK_ACKBIT
; there was an ACK error
	bne	L0004A
; next byte
	iny
; update the byte counter
	dex
; back around for more bytes.
	bne	L0004B

	lda	#$00
L0004A:
	ldx	#$00

	jsr     incsp1
	rts
.endproc




; ---------------------------------------------------------------
; unsigned char __near__ i2cGetByteAck (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cGetByteAck: near

.segment	"CODE"

	ldx	#I2C_CMDRXACK
	stx	I2C_CMDREG
	lda	I2C_DATRDREG
	tax

L0005:
	lda	I2C_CMDREG
	and	#I2C_MASK_SFTRDY
	beq	L0005

	txa
	ldx	#$00
	rts

.endproc


; ---------------------------------------------------------------
; unsigned char __near__ i2cGetByteNack (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cGetByteNack: near

.segment	"CODE"

	ldx	#I2C_CMDRXNACK
	stx	I2C_CMDREG
	lda	I2C_DATRDREG
	tax

L0005:
	lda	I2C_CMDREG
	and	#I2C_MASK_SFTRDY
	beq	L0005

	txa
	ldx	#$00
	rts

.endproc


; ---------------------------------------------------------------
; unsigned char __near__ i2cGetNBytes (unsigned char nrBytes, unsigned int bufAdr)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_i2cGetNBytes: near

.segment	"CODE"

; save the passed address to a safe place
; CC65 has these for our use
;
	sta	ptr1
	stx	ptr1 + 1

; set up the I2C controller
	lda	#I2C_CMDRXACK
	sta	I2C_CMDREG

; get the number of bytes to transfer
	ldy     #$00
	lda	(sp), y
	tax

; do a dummy read. this shifts in the first
; actual data byte from the I2C peripheral
	lda	I2C_DATRDREG
;	ldy	#10
;L0006A:
;	dey
;	bne	L0006A

L0006A:
	lda	I2C_CMDREG
	and	#I2C_MASK_SFTRDY
	beq	L0006A



; (ptr1), y will now point to buffer location
; where the read byte will be put
        ldy	#$00

L0006B:
; read the byte in the I2C FSM receive register
; and get the next
	lda	I2C_DATRDREG
	sta	(ptr1), y

; wait for the shifter to be ready
L0006:
	lda	I2C_CMDREG
	and	#I2C_MASK_SFTRDY
	beq	L0006
; next byte
	iny
; update the byte counter
	dex
; back around for more bytes.
	bne	L0006B

; do a dummy read with a NACK to end the transaction
	jsr	_i2cGetByteNack


exit:

	lda	#$00
	ldx	#$00

	jsr     incsp1
	rts

.endproc



