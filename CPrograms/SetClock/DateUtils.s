;
; File generated by cc65 v 2.18 - Git bf4b195
;
	.fopt		compiler,"cc65 v 2.18 - Git bf4b195"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_printf
	.import		_bcdToChar
	.import		_g_rtcRegs
	.import		_g_numBuf
	.export		_dayStr
	.export		_printDayName
	.export		_monthStr
	.export		_printMonthName
	.export		_printDate
	.export		_dayOfWeek
	.export		_isLeapYear
	.export		_monLen
	.export		_checkMonthLength
	.export		_getMonthNr

.segment	"DATA"

_dayStr:
	.byte	$53,$75,$6E,$00,$4D,$6F,$6E,$00,$54,$75,$65,$00,$57,$65,$64,$00
	.byte	$54,$68,$75,$00,$46,$72,$69,$00,$53,$61,$74,$00,$00
_monthStr:
	.byte	$4A,$61,$6E,$00,$46,$65,$62,$00,$4D,$61,$72,$00,$41,$70,$72,$00
	.byte	$4D,$61,$79,$00,$4A,$75,$6E,$00,$4A,$75,$6C,$00,$41,$75,$67,$00
	.byte	$53,$65,$70,$00,$4F,$63,$74,$00,$4E,$6F,$76,$00,$44,$65,$63,$00
	.byte	$00
_monLen:
	.byte	$1F
	.byte	$1C
	.byte	$1F
	.byte	$1E
	.byte	$1F
	.byte	$1E
	.byte	$1F
	.byte	$1F
	.byte	$1E
	.byte	$1F
	.byte	$1E
	.byte	$1F

.segment	"RODATA"

S0005:
	.byte	$20,$25,$30,$32,$78,$20,$00
S0009:
	.byte	$25,$30,$32,$78,$00
S0004:
	.byte	$25,$73,$00
S0007:
	.byte	$32,$31,$00
S0008:
	.byte	$32,$30,$00
S0002	:=	S0004+0
S0006	:=	S0005+5

; ---------------------------------------------------------------
; void __near__ printDayName (unsigned char dayNr)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printDayName: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; --dayNr;
;
	ldy     #$00
	ldx     #$00
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
;
; if (dayNr > 6) dayNr = 6;
;
	ldy     #$00
	ldx     #$00
	lda     (sp),y
	cmp     #$07
	lda     #$00
	ldx     #$00
	rol     a
	jeq     L0002
	ldx     #$00
	lda     #$06
	ldy     #$00
	sta     (sp),y
;
; printf("%s", (&dayStr[0] + (dayNr << 2)));
;
L0002:	lda     #<(S0002)
	ldx     #>(S0002)
	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax2
	clc
	adc     #<(_dayStr)
	tay
	txa
	adc     #>(_dayStr)
	tax
	tya
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; }
;
	jsr     incsp1
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ printMonthName (unsigned char monthNr)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printMonthName: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; --monthNr;
;
	ldy     #$00
	ldx     #$00
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
;
; if (monthNr > 11) monthNr = 11;
;
	ldy     #$00
	ldx     #$00
	lda     (sp),y
	cmp     #$0C
	lda     #$00
	ldx     #$00
	rol     a
	jeq     L0002
	ldx     #$00
	lda     #$0B
	ldy     #$00
	sta     (sp),y
;
; printf("%s", (&monthStr[0] + (monthNr << 2)));
;
L0002:	lda     #<(S0004)
	ldx     #>(S0004)
	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax2
	clc
	adc     #<(_monthStr)
	tay
	txa
	adc     #>(_monthStr)
	tax
	tya
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; }
;
	jsr     incsp1
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ printDate (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printDate: near

.segment	"CODE"

;
; printDayName(g_rtcRegs[3] & 0x07);
;
	ldx     #$00
	lda     _g_rtcRegs+3
	ldx     #$00
	and     #$07
	ldx     #$00
	jsr     _printDayName
;
; printf(" %02x ", g_rtcRegs[4] & 0x3F);
;
	lda     #<(S0005)
	ldx     #>(S0005)
	jsr     pushax
	ldx     #$00
	lda     _g_rtcRegs+4
	ldx     #$00
	and     #$3F
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; printMonthName(bcdToChar(g_rtcRegs[5] & 0x1F));
;
	ldx     #$00
	lda     _g_rtcRegs+5
	ldx     #$00
	and     #$1F
	ldx     #$00
	jsr     _bcdToChar
	jsr     _printMonthName
;
; printf(" ");
;
	lda     #<(S0006)
	ldx     #>(S0006)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (g_rtcRegs[5] & 0x80)
;
	ldx     #$00
	lda     _g_rtcRegs+5
	ldx     #$00
	and     #$80
	stx     tmp1
	ora     tmp1
	jeq     L0002
;
; printf("21");
;
	lda     #<(S0007)
	ldx     #>(S0007)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; } else {
;
	jmp     L0003
;
; printf("20");
;
L0002:	lda     #<(S0008)
	ldx     #>(S0008)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; printf("%02x", g_rtcRegs[6]);
;
L0003:	lda     #<(S0009)
	ldx     #>(S0009)
	jsr     pushax
	ldx     #$00
	lda     _g_rtcRegs+6
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ dayOfWeek (unsigned char day, unsigned char month, unsigned int year)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dayOfWeek: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; if ((day > 31) || (month > 12) || (year < 1582)) return 0xFF;
;
	ldy     #$09
	jsr     subysp
	ldy     #$0C
	ldx     #$00
	lda     (sp),y
	cmp     #$20
	lda     #$00
	ldx     #$00
	rol     a
	jne     L0003
	ldy     #$0B
	ldx     #$00
	lda     (sp),y
	cmp     #$0D
	lda     #$00
	ldx     #$00
	rol     a
	jne     L0003
	ldy     #$0A
	jsr     ldaxysp
	cpx     #$06
	bne     L0004
	cmp     #$2E
L0004:	jsr     boolult
	jne     L0003
	ldx     #$00
	lda     #$00
	jeq     L0005
L0003:	ldx     #$00
	lda     #$01
L0005:	jeq     L0002
	ldx     #$00
	lda     #$FF
	jmp     L0001
;
; if ((day == 0) || (month == 0)) return 0xFF;
;
L0002:	ldy     #$0C
	ldx     #$00
	lda     (sp),y
	cmp     #$00
	jsr     booleq
	jne     L0007
	ldy     #$0B
	ldx     #$00
	lda     (sp),y
	cmp     #$00
	jsr     booleq
	jne     L0007
	ldx     #$00
	lda     #$00
	jeq     L0008
L0007:	ldx     #$00
	lda     #$01
L0008:	jeq     L0006
	ldx     #$00
	lda     #$FF
	jmp     L0001
;
; factor = 365L * year + day + 31L * (month - 1);
;
L0006:	ldy     #$0A
	jsr     ldaxysp
	jsr     axulong
	jsr     pusheax
	ldx     #$01
	lda     #$00
	sta     sreg
	lda     #$00
	sta     sreg+1
	lda     #$6D
	jsr     tosmuleax
	jsr     pusheax
	ldy     #$10
	ldx     #$00
	lda     (sp),y
	jsr     axulong
	jsr     tosaddeax
	jsr     pusheax
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	jsr     decax1
	jsr     axlong
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$1F
	jsr     tosmuleax
	jsr     tosaddeax
	ldy     #$05
	jsr     steaxysp
;
; switch (month)
;
	ldy     #$0B
	ldx     #$00
	lda     (sp),y
;
; {
;
	jmp     L0009
;
; }
;
L0009:	cmp     #$01
	jeq     L000B
	cmp     #$02
	jeq     L000B
	jmp     L000D
;
; factor += (year - 1) >> 2;
;
L000B:	ldy     #$0A
	jsr     ldaxysp
	jsr     decax1
	jsr     shrax2
	jsr     axulong
	ldy     #$05
	jsr     laddeqysp
;
; x = ((3L * ((year - 1) / 100L)) >> 2) + 1;
;
	ldy     #$0A
	jsr     ldaxysp
	jsr     decax1
	jsr     axulong
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$64
	jsr     tosdiveax
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$03
	jsr     tosmuleax
	jsr     asreax2
	ldy     #$01
	jsr     inceaxy
	ldy     #$01
	jsr     steaxysp
;
; factor -= x;
;
	ldy     #$04
	jsr     ldeaxysp
	ldy     #$05
	jsr     lsubeqysp
;
; break;
;
	jmp     L000A
;
; factor -= ((month << 2) + 23L) / 10L;
;
L000D:	ldy     #$0B
	ldx     #$00
	lda     (sp),y
	jsr     aslax2
	jsr     axlong
	ldy     #$17
	jsr     inceaxy
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$0A
	jsr     tosdiveax
	ldy     #$05
	jsr     lsubeqysp
;
; factor += year >> 2;
;
	ldy     #$0A
	jsr     ldaxysp
	jsr     shrax2
	jsr     axulong
	ldy     #$05
	jsr     laddeqysp
;
; factor -= ((3L * (year / 100L)) >> 2) + 1;
;
	ldy     #$0A
	jsr     ldaxysp
	jsr     axulong
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$64
	jsr     tosdiveax
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$03
	jsr     tosmuleax
	jsr     asreax2
	ldy     #$01
	jsr     inceaxy
	ldy     #$05
	jsr     lsubeqysp
;
; break;
;
	jmp     L000A
;
; dx = (unsigned char)(factor % 7) + 1;
;
L000A:	ldy     #$08
	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$07
	jsr     tosumodeax
	ldx     #$00
	jsr     incax1
	ldx     #$00
	ldy     #$00
	sta     (sp),y
;
; return dx;
;
	ldy     #$00
	ldx     #$00
	lda     (sp),y
	jmp     L0001
;
; }
;
L0001:	ldy     #$0D
	jsr     addysp
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ isLeapYear (unsigned int y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_isLeapYear: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; if(y % 400) return 1;
;
	ldy     #$01
	jsr     ldaxysp
	jsr     pushax
	ldx     #$01
	lda     #$90
	jsr     tosumodax
	stx     tmp1
	ora     tmp1
	jeq     L0002
	ldx     #$00
	lda     #$01
	jmp     L0001
;
; if(y % 100) return 0;
;
L0002:	ldy     #$01
	jsr     ldaxysp
	jsr     pushax
	ldx     #$00
	lda     #$64
	jsr     tosumodax
	stx     tmp1
	ora     tmp1
	jeq     L0003
	ldx     #$00
	lda     #$00
	jmp     L0001
;
; if (y % 4) return 1;
;
L0003:	ldy     #$01
	jsr     ldaxysp
	ldx     #$00
	and     #$03
	stx     tmp1
	ora     tmp1
	jeq     L0004
	ldx     #$00
	lda     #$01
	jmp     L0001
;
; return 0;
;
L0004:	ldx     #$00
	lda     #$00
	jmp     L0001
;
; }
;
L0001:	jsr     incsp2
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ checkMonthLength (unsigned char d, unsigned char m, unsigned int y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkMonthLength: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; m--;
;
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	pha
	sec
	sbc     #$01
	ldy     #$02
	sta     (sp),y
	pla
;
; if (m == 1)
;
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	cmp     #$01
	jsr     booleq
	jeq     L0002
;
; if (d <= (monLen[1] + isLeapYear(y))) return 0;
;
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	jsr     pushax
	ldx     #$00
	lda     _monLen+1
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _isLeapYear
	jsr     tosaddax
	jsr     tosleax
	jeq     L0003
	ldx     #$00
	lda     #$00
	jmp     L0001
;
; } else {
;
L0003:	jmp     L0005
;
; if (d <= monLen[m]) return 0;
;
L0002:	ldy     #$03
	ldx     #$00
	lda     (sp),y
	jsr     pushax
	lda     #<(_monLen)
	ldx     #>(_monLen)
	ldy     #$04
	clc
	adc     (sp),y
	bcc     L0006
	inx
L0006:	ldy     #$00
	jsr     ldauidx
	jsr     tosuleax
	jeq     L0005
	ldx     #$00
	lda     #$00
	jmp     L0001
;
; return 255;
;
L0005:	ldx     #$00
	lda     #$FF
	jmp     L0001
;
; }
;
L0001:	jsr     incsp4
	rts

.endproc

; ---------------------------------------------------------------
; unsigned int __near__ getMonthNr (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getMonthNr: near

.segment	"CODE"

;
; switch(g_numBuf[0])
;
	ldx     #$00
	lda     _g_numBuf
;
; {
;
	jmp     L0002
;
; }
;
L0002:	cmp     #$41
	jeq     L001A
	cmp     #$44
	jeq     L0027
	cmp     #$46
	jeq     L000F
	cmp     #$4A
	jeq     L0005
	cmp     #$4D
	jeq     L0012
	cmp     #$4E
	jeq     L0025
	cmp     #$4F
	jeq     L0023
	cmp     #$53
	jeq     L0021
	cmp     #$61
	jeq     L001A
	cmp     #$64
	jeq     L0027
	cmp     #$66
	jeq     L000F
	cmp     #$6A
	jeq     L0005
	cmp     #$6D
	jeq     L0012
	cmp     #$6E
	jeq     L0025
	cmp     #$6F
	jeq     L0023
	cmp     #$73
	jeq     L0021
	jmp     L0029
;
; if ((g_numBuf[2] == 'a') || (g_numBuf[2] == 'A')) return 1;
;
L0005:	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$61
	jsr     booleq
	jne     L0007
	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$41
	jsr     booleq
	jne     L0007
	ldx     #$00
	lda     #$00
	jeq     L0008
L0007:	ldx     #$00
	lda     #$01
L0008:	jeq     L0006
	ldx     #$00
	lda     #$01
	jmp     L0003
;
; if ((g_numBuf[2] == 'n') || (g_numBuf[2] == 'N')) return 6;
;
L0006:	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$6E
	jsr     booleq
	jne     L000A
	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$4E
	jsr     booleq
	jne     L000A
	ldx     #$00
	lda     #$00
	jeq     L000B
L000A:	ldx     #$00
	lda     #$01
L000B:	jeq     L0009
	ldx     #$00
	lda     #$06
	jmp     L0003
;
; if ((g_numBuf[2] == 'l') || (g_numBuf[2] == 'L')) return 7;
;
L0009:	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$6C
	jsr     booleq
	jne     L000D
	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$4C
	jsr     booleq
	jne     L000D
	ldx     #$00
	lda     #$00
	jeq     L000E
L000D:	ldx     #$00
	lda     #$01
L000E:	jeq     L000C
	ldx     #$00
	lda     #$07
	jmp     L0003
;
; return 255;
;
L000C:	ldx     #$00
	lda     #$FF
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; return 2;
;
L000F:	ldx     #$00
	lda     #$02
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; if ((g_numBuf[2] == 'r') || (g_numBuf[2] == 'R')) return 3;
;
L0012:	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$72
	jsr     booleq
	jne     L0014
	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$52
	jsr     booleq
	jne     L0014
	ldx     #$00
	lda     #$00
	jeq     L0015
L0014:	ldx     #$00
	lda     #$01
L0015:	jeq     L0013
	ldx     #$00
	lda     #$03
	jmp     L0003
;
; if ((g_numBuf[2] == 'y') || (g_numBuf[2] == 'Y')) return 5;
;
L0013:	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$79
	jsr     booleq
	jne     L0017
	ldx     #$00
	lda     _g_numBuf+2
	cmp     #$59
	jsr     booleq
	jne     L0017
	ldx     #$00
	lda     #$00
	jeq     L0018
L0017:	ldx     #$00
	lda     #$01
L0018:	jeq     L0016
	ldx     #$00
	lda     #$05
	jmp     L0003
;
; return 255;
;
L0016:	ldx     #$00
	lda     #$FF
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; if ((g_numBuf[1] == 'p') || (g_numBuf[1] == 'P')) return 4;
;
L001A:	ldx     #$00
	lda     _g_numBuf+1
	cmp     #$70
	jsr     booleq
	jne     L001C
	ldx     #$00
	lda     _g_numBuf+1
	cmp     #$50
	jsr     booleq
	jne     L001C
	ldx     #$00
	lda     #$00
	jeq     L001D
L001C:	ldx     #$00
	lda     #$01
L001D:	jeq     L001B
	ldx     #$00
	lda     #$04
	jmp     L0003
;
; if ((g_numBuf[1] == 'u') || (g_numBuf[1] == 'U')) return 8;
;
L001B:	ldx     #$00
	lda     _g_numBuf+1
	cmp     #$75
	jsr     booleq
	jne     L001F
	ldx     #$00
	lda     _g_numBuf+1
	cmp     #$55
	jsr     booleq
	jne     L001F
	ldx     #$00
	lda     #$00
	jeq     L0020
L001F:	ldx     #$00
	lda     #$01
L0020:	jeq     L001E
	ldx     #$00
	lda     #$08
	jmp     L0003
;
; return 0;
;
L001E:	ldx     #$00
	lda     #$00
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; return 9;
;
L0021:	ldx     #$00
	lda     #$09
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; return 10;
;
L0023:	ldx     #$00
	lda     #$0A
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; return 11;
;
L0025:	ldx     #$00
	lda     #$0B
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; return 12;
;
L0027:	ldx     #$00
	lda     #$0C
	jmp     L0003
;
; break;
;
	jmp     L0003
;
; return 0xFF;
;
L0029:	ldx     #$00
	lda     #$FF
	jmp     L0003
;
; }
;
L0003:	rts

.endproc

